<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>多选checkbox</title>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
        <div class="box"></div>
    </div>
    <canvas id="canvas" style="position: absolute; z-index: 1;top: 0;left: 0"></canvas>
</body>
<style>
    body {
        padding: 0;
        margin: 0;
        width: 100vw;
        height: 100vh;
        background-color: #eaeaea;
    }
    .container {
        position: relative;
        width: 400px;
        height: 400px;
        display: grid;
        grid-template-columns: repeat(6,1fr);
        grid-template-rows: repeat(3,0.15fr);
        background-color: #ffffff;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        grid-gap: 10px;
        padding: 10px;
    }
    .box {
        background-color: #b9b9b9;
        width: 100%;
        height: 100%;
    }
</style>
<script>
    //思路，获取每个元素距离页面上边距和左边距的距离，然后添加鼠标监听事件。
    //只要左边距和上边距都满足要求，则是被选中

    const elArray = document.querySelectorAll(".box");
    const canvas = document.getElementById("canvas");
    let ctx;
    let allCheckboxInfo;
    let xIndex = [];    //横向的X坐标结点，xIndex.length就代表了横向所存放元素的最大值。
    let yIndex = [];    //纵向的Y坐标节点
    let elTargets = [];   //被选中的元素下角标
    let startMousePos = {      //确定鼠标按下时的坐标 （用于画框和计算起始点）
        X : 0,
        Y : 0
    }

    window.onload = ()=> {
        init();
    }
    //页面放缩时重绘
    window.onresize = () => {
        init();
    }

    //初始化函数
    function init() {
        allCheckboxInfo = [];
        canvas.width = document.body.clientWidth;
        canvas.height = document.body.clientHeight;
        ctx = canvas.getContext('2d');
        let width = 0;
        let height = 0;
        elArray.forEach((el) => {
            let rect = el.getBoundingClientRect();
            let checkboxInfo = {
                X : 0,
                Y : 0
            };
            //获取left和top
            checkboxInfo.Y = rect.top + rect.height / 2;
            checkboxInfo.X = rect.left + rect.width / 2;
            if (width < checkboxInfo.X) {
                xIndex.push(checkboxInfo.X);
                width = checkboxInfo.X
            }
            if (height < checkboxInfo.Y) {
                yIndex.push(checkboxInfo.Y);
                height = checkboxInfo.Y;
            }

            //存放所有box的信息
            allCheckboxInfo.push(checkboxInfo);
        });
    }

    //添加监听
    window.onmousedown = (e) => {
        startMousePos.X = e.pageX;
        startMousePos.Y = e.pageY;
        window.addEventListener("mousemove",mousemove);
    }
    //移除监听
    window.onmouseup = () => {
        //清空存放选中的元素的elTargets
        elTargets.forEach(value => {
            elArray[value].style.backgroundColor = "";
        })
        elTargets = [];
        ctx.clearRect(0,0,canvas.width,canvas.height);
        window.removeEventListener("mousemove",mousemove);
    }

    /**
     * 这个方法是计算鼠标按下时的坐标于当前鼠标位置坐标所形成的矩阵，并获取处于矩阵中的元素下角标。
     * @param e
     */
    function mousemove(e) {
        e.preventDefault();
        let x = e.pageX;
        let y = e.pageY;
        draw(x,y);

        let start = [0,0];
        let end = [0,0];
        let targets = [];   //用于存放当前元素下角标，目的是为了找出与上一次所存放的下角标的差异，来动态的更新被选中元素
        //从左上角为起点
        if (startMousePos.X < x && startMousePos.Y < y && startMousePos.X <= xIndex[xIndex.length - 1] && startMousePos.Y <= yIndex[yIndex.length - 1]) {
            xIndex.forEach((value, index) => {
                if (startMousePos.X > value) {
                    start[0] = index + 1;
                }
                if (x > value) {
                    end[0] = index + 1;
                }
            })
            yIndex.forEach((value, index) => {
                if (startMousePos.Y > value) {
                    start[1] = index + 1;
                }
                if (y > value) {
                    end[1] = index + 1;
                }
            })
            for (let i = start[0] + 1; i <= end[0]; i++) {
                for (let j = start[1] + 1; j <= end[1]; j++) {
                    targets.push(((j - 1) * 6 + i) - 1);
                }
            }
        }
        //右上角为起点
        if (startMousePos.X > x && startMousePos.Y < y && x <= xIndex[xIndex.length - 1] && startMousePos.Y <= yIndex[yIndex.length - 1]) {
            xIndex.forEach((value, index) => {
                if (x > value) {
                    start[0] = index + 1;
                }
                if (startMousePos.X > value) {
                    end[0] = index + 1;
                }
            })
            yIndex.forEach((value, index) => {
                if (startMousePos.Y > value) {
                    start[1] = index + 1;
                }
                if (y > value) {
                    end[1] = index + 1;
                }
            })
            for (let i = start[0] + 1; i <= end[0]; i++) {
                for (let j = start[1] + 1; j <= end[1]; j++) {
                    targets.push(((j - 1) * 6 + i) - 1);
                }
            }
        }
        //左下角为起点
        if (startMousePos.X < x && startMousePos.Y > y && startMousePos.X <= xIndex[xIndex.length - 1] && startMousePos.Y >= yIndex[0]) {
            xIndex.forEach((value, index) => {
                if (startMousePos.X > value) {
                    start[0] = index + 1;
                }
                if (x > value) {
                    end[0] = index + 1;
                }
            })
            yIndex.forEach((value, index) => {
                if (y > value) {
                    start[1] = index + 1;
                }
                if (startMousePos.Y > value) {
                    end[1] = index + 1;
                }
            })
            for (let i = start[0] + 1; i <= end[0]; i++) {
                for (let j = start[1] + 1; j <= end[1]; j++) {
                    targets.push(((j - 1) * 6 + i) - 1);
                }
            }
        }
        //右下角为起点
        if (startMousePos.X > x && startMousePos.Y > y && startMousePos.X >= xIndex[0] && startMousePos.Y >= yIndex[0]) {
            xIndex.forEach((value, index) => {
                if (x > value) {
                    start[0] = index + 1;
                }
                if (startMousePos.X > value) {
                    end[0] = index + 1;
                }
            })
            yIndex.forEach((value, index) => {
                if (y > value) {
                    start[1] = index + 1;
                }
                if (startMousePos.Y > value) {
                    end[1] = index + 1;
                }
            })
            for (let i = start[0] + 1; i <= end[0]; i++) {
                for (let j = start[1] + 1; j <= end[1]; j++) {
                    targets.push(((j - 1) * 6 + i) - 1);
                }
            }
        }

        changeColor(targets);

    }

    /**
     * 更新选中元素的颜色，动态去掉elTargets中多余的元素。
     * @param target
     */
    function changeColor(target) {
        for (const key in target) {
            elTargets.findIndex((value) => {
                console.log(value);
            })
        }
        //去掉未被选中的元素角标
        for (const key in elTargets) {
            if (target.findIndex(value => elTargets[key] === value) === -1) {
                console.log(key);
                elArray[elTargets[key]].style.backgroundColor = "";
                elTargets.splice(Number(key),1);
            }
        }
        //将新选中的元素角标添加进elTarget
        for (const key in target) {
            if (elTargets.findIndex(value => target[key] === value) === -1) {
                elArray[target[key]].style.backgroundColor = "blue";
                elTargets.push(target[key]);
            }
        }


    }

    /**
     * 画出选中区域
     * @param X
     * @param Y
     */
    function draw(X,Y) {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.beginPath();
        ctx.rect(startMousePos.X, startMousePos.Y, X - startMousePos.X, Y - startMousePos.Y);
        ctx.stroke();
    }
</script>
</html>